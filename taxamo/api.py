#!/usr/bin/env python
"""
Copyright 2014-2021 by Taxamo

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at [apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0)

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
"""
import sys
import os

from models import *


class ApiApi(object):

    def __init__(self, apiClient):
      self.apiClient = apiClient

    

    def createRefund(self, key, body, **kwargs):
        """Create a refund

        Args:
            key, str: Transaction key. (required)

            body, createRefundIn: Input (required)

            

        Returns: createRefundOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createRefund" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/refunds'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createRefundOut')
        return responseObject
        

        

    def listRefunds(self, key, **kwargs):
        """Get transaction refunds

        Args:
            key, str: Transaction key. (required)

            

        Returns: listRefundsOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listRefunds" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/refunds'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'listRefundsOut')
        return responseObject
        

        

    def cancelRefundBySubnumber(self, key, refund_note_subnumber, refund_key_or_refund_note_number, **kwargs):
        """Cancel refund by subnumber

        Args:
            key, str: Transaction key. (required)

            refund_note_subnumber, str: Refund note subnumber. (required)

            refund_key_or_refund_note_number, str: Refund key or refund note number. (required)

            

        Returns: cancelRefundBySubnumberOut
        """

        allParams = ['key', 'refund_note_subnumber', 'refund_key_or_refund_note_number']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method cancelRefundBySubnumber" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/refunds/{refund_key_or_refund_note_number}/{refund_note_subnumber}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        if ('refund_note_subnumber' in params):
            replacement = str(self.apiClient.toPathValue(params['refund_note_subnumber']))
            resourcePath = resourcePath.replace('{' + 'refund_note_subnumber' + '}',
                                                replacement)
        if ('refund_key_or_refund_note_number' in params):
            replacement = str(self.apiClient.toPathValue(params['refund_key_or_refund_note_number']))
            resourcePath = resourcePath.replace('{' + 'refund_key_or_refund_note_number' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'cancelRefundBySubnumberOut')
        return responseObject
        

        

    def cancelRefunds(self, key, refund_key_or_refund_note_number, **kwargs):
        """Cancel refund or refunds

        Args:
            key, str: Transaction key. (required)

            refund_key_or_refund_note_number, str: Refund key or refund note number. (required)

            

        Returns: cancelRefundsOut
        """

        allParams = ['key', 'refund_key_or_refund_note_number']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method cancelRefunds" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/refunds/{refund_key_or_refund_note_number}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        if ('refund_key_or_refund_note_number' in params):
            replacement = str(self.apiClient.toPathValue(params['refund_key_or_refund_note_number']))
            resourcePath = resourcePath.replace('{' + 'refund_key_or_refund_note_number' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'cancelRefundsOut')
        return responseObject
        

        

    def createPayment(self, key, body, **kwargs):
        """Register a payment

        Args:
            key, str: Transaction key. (required)

            body, createPaymentIn: Input (required)

            

        Returns: createPaymentOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createPayment" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/payments'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createPaymentOut')
        return responseObject
        

        

    def listPayments(self, key, **kwargs):
        """List payments

        Args:
            limit, str: Max record count (no more than 100, defaults to 10). (optional)

            offset, str: How many records need to be skipped, defaults to 0. (optional)

            key, str: Transaction key. (required)

            

        Returns: listPaymentsOut
        """

        allParams = ['limit', 'offset', 'key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listPayments" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/payments'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('limit' in params):
            queryParams['limit'] = self.apiClient.toPathValue(params['limit'])
        if ('offset' in params):
            queryParams['offset'] = self.apiClient.toPathValue(params['offset'])
        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'listPaymentsOut')
        return responseObject
        

        

    def capturePayment(self, key, **kwargs):
        """Capture payment

        Args:
            key, str: Transaction key. (required)

            

        Returns: capturePaymentOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method capturePayment" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/payments/capture'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'capturePaymentOut')
        return responseObject
        

        

    def emailInvoice(self, key, body, **kwargs):
        """Email invoice

        Args:
            key, str: Transaction key. (optional)

            body, emailInvoiceIn: Input (required)

            

        Returns: emailInvoiceOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method emailInvoice" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/invoice/send_email'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'emailInvoiceOut')
        return responseObject
        

        

    def emailRefund(self, key, refund_note_number, body, **kwargs):
        """Email credit note

        Args:
            key, str: Transaction key. (required)

            refund_note_number, str: Refund note id. (required)

            body, emailRefundIn: Input (required)

            

        Returns: emailRefundOut
        """

        allParams = ['key', 'refund_note_number', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method emailRefund" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/invoice/refunds/{refund_note_number}/send_email'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        if ('refund_note_number' in params):
            replacement = str(self.apiClient.toPathValue(params['refund_note_number']))
            resourcePath = resourcePath.replace('{' + 'refund_note_number' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'emailRefundOut')
        return responseObject
        

        

    def createTransaction(self, body, **kwargs):
        """Store transaction

        Args:
            body, createTransactionIn: Input (required)

            

        Returns: createTransactionOut
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createTransactionOut')
        return responseObject
        

        

    def getTransaction(self, key, **kwargs):
        """Retrieve transaction data.

        Args:
            key, str: Transaction key (required)

            

        Returns: getTransactionOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getTransactionOut')
        return responseObject
        

        

    def updateTransaction(self, key, body, **kwargs):
        """Update transaction

        Args:
            key, str: Transaction key. (optional)

            body, updateTransactionIn: Input (required)

            

        Returns: updateTransactionOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method updateTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'updateTransactionOut')
        return responseObject
        

        

    def confirmTransaction(self, key, body=None, **kwargs):
        """Confirm transaction

        Args:
            key, str: Transaction key. (optional)

            body, confirmTransactionIn: Input (required)

            

        Returns: confirmTransactionOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method confirmTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/confirm'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'confirmTransactionOut')
        return responseObject
        

        

    def cancelTransaction(self, key, **kwargs):
        """Delete transaction

        Args:
            key, str: Transaction key (optional)

            

        Returns: cancelTransactionOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method cancelTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'cancelTransactionOut')
        return responseObject
        

        

    def unconfirmTransaction(self, key, body, **kwargs):
        """Un-confirm the transaction

        Args:
            key, str: Transaction key. (optional)

            body, unconfirmTransactionIn: Input (required)

            

        Returns: unconfirmTransactionOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method unconfirmTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/unconfirm'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'unconfirmTransactionOut')
        return responseObject
        

        

    def listTransactions(self, **kwargs):
        """Browse transactions

        Args:
            has_sub_account_id, bool: Only return transactions with sub_account_id set. (optional)

            filter_text, str: Filtering expression. Placeholder field, not supported yet. (optional)

            offset, integer: Offset (optional)

            has_note, bool: Return only transactions with a note field set. (optional)

            key_or_custom_id, str: Taxamo provided transaction key or custom id (optional)

            currency_code, str: Three letter ISO currency code. (optional)

            buyer_tax_number_not, str: Only return transactions without provided number or with a different buyer tax number. (optional)

            order_date_to, str: Order date to in yyyy-MM-dd format. (optional)

            no_sub_account_id, bool: Only return transactions without sub_account_id set. (optional)

            sort_reverse, bool: If true, results are sorted in descending order. (optional)

            limit, integer: Limit (no more than 1000, defaults to 100). (optional)

            buyer_tax_number, str: Only return transactions with a provided buyer tax number. (optional)

            invoice_number, str: Transaction invoice number. (optional)

            tax_country_codes, str: Comma separated list of two letter ISO tax country codes. (optional)

            product_classes, str: Only return transactions with a provided product classes (optional)

            external_unique_id, str: Search by the external unique id (optional)

            statuses, str: Comma separated list of of transaction statuses. 'N' - unconfirmed transaction, 'C' - confirmed transaction. (optional)

            original_transaction_key, str: Taxamo provided original transaction key (optional)

            order_date_from, str: Order date from in yyyy-MM-dd format. (optional)

            total_amount_greater_than, str: Return only transactions with total amount greater than given number. Transactions with total amount equal to a given number (e.g. 0) are not returned. (optional)

            format, str: Output format - supports 'csv' value for this operation. (optional)

            total_amount_less_than, str: Return only transactions with total amount less than a given number. Transactions with total amount equal to a given number (e.g. 1) are not returned. (optional)

            tax_country_code, str: Two letter ISO tax country code. (optional)

            

        Returns: listTransactionsOut
        """

        allParams = ['has_sub_account_id', 'filter_text', 'offset', 'has_note', 'key_or_custom_id', 'currency_code', 'buyer_tax_number_not', 'order_date_to', 'no_sub_account_id', 'sort_reverse', 'limit', 'buyer_tax_number', 'invoice_number', 'tax_country_codes', 'product_classes', 'external_unique_id', 'statuses', 'original_transaction_key', 'order_date_from', 'total_amount_greater_than', 'format', 'total_amount_less_than', 'tax_country_code']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listTransactions" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('has_sub_account_id' in params):
            queryParams['has_sub_account_id'] = self.apiClient.toPathValue(params['has_sub_account_id'])
        if ('filter_text' in params):
            queryParams['filter_text'] = self.apiClient.toPathValue(params['filter_text'])
        if ('offset' in params):
            queryParams['offset'] = self.apiClient.toPathValue(params['offset'])
        if ('has_note' in params):
            queryParams['has_note'] = self.apiClient.toPathValue(params['has_note'])
        if ('key_or_custom_id' in params):
            queryParams['key_or_custom_id'] = self.apiClient.toPathValue(params['key_or_custom_id'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('buyer_tax_number_not' in params):
            queryParams['buyer_tax_number_not'] = self.apiClient.toPathValue(params['buyer_tax_number_not'])
        if ('order_date_to' in params):
            queryParams['order_date_to'] = self.apiClient.toPathValue(params['order_date_to'])
        if ('no_sub_account_id' in params):
            queryParams['no_sub_account_id'] = self.apiClient.toPathValue(params['no_sub_account_id'])
        if ('sort_reverse' in params):
            queryParams['sort_reverse'] = self.apiClient.toPathValue(params['sort_reverse'])
        if ('limit' in params):
            queryParams['limit'] = self.apiClient.toPathValue(params['limit'])
        if ('buyer_tax_number' in params):
            queryParams['buyer_tax_number'] = self.apiClient.toPathValue(params['buyer_tax_number'])
        if ('invoice_number' in params):
            queryParams['invoice_number'] = self.apiClient.toPathValue(params['invoice_number'])
        if ('tax_country_codes' in params):
            queryParams['tax_country_codes'] = self.apiClient.toPathValue(params['tax_country_codes'])
        if ('product_classes' in params):
            queryParams['product_classes'] = self.apiClient.toPathValue(params['product_classes'])
        if ('external_unique_id' in params):
            queryParams['external_unique_id'] = self.apiClient.toPathValue(params['external_unique_id'])
        if ('statuses' in params):
            queryParams['statuses'] = self.apiClient.toPathValue(params['statuses'])
        if ('original_transaction_key' in params):
            queryParams['original_transaction_key'] = self.apiClient.toPathValue(params['original_transaction_key'])
        if ('order_date_from' in params):
            queryParams['order_date_from'] = self.apiClient.toPathValue(params['order_date_from'])
        if ('total_amount_greater_than' in params):
            queryParams['total_amount_greater_than'] = self.apiClient.toPathValue(params['total_amount_greater_than'])
        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('total_amount_less_than' in params):
            queryParams['total_amount_less_than'] = self.apiClient.toPathValue(params['total_amount_less_than'])
        if ('tax_country_code' in params):
            queryParams['tax_country_code'] = self.apiClient.toPathValue(params['tax_country_code'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'listTransactionsOut')
        return responseObject
        

        

    def calculateTax(self, body, **kwargs):
        """Calculate tax

        Args:
            body, calculateTaxIn: Input (required)

            

        Returns: calculateTaxOut
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method calculateTax" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/calculate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'calculateTaxOut')
        return responseObject
        

        

    def calculateSimpleTax(self, currency_code, **kwargs):
        """Simple tax

        Args:
            product_type, str: Product type, according to dictionary /dictionaries/product_types.  (optional)

            invoice_address_city, str: Invoice address/postal_code (optional)

            buyer_credit_card_prefix, str: First 6 digits of buyer's credit card prefix. (optional)

            currency_code, str: Currency code for transaction - e.g. EUR. (required)

            invoice_address_region, str: Invoice address/region (optional)

            unit_price, number: Unit price. (optional)

            quantity, number: Quantity Defaults to 1. (optional)

            buyer_tax_number, str:  Buyer's tax number - EU VAT number for example. If using EU VAT number, it is possible to provide country code in it (e.g. IE1234567X) or simply use billing_country_code field for that. In the first case, if billing_country_code value was provided, it will be overwritten with country code value extracted from VAT number - but only if the VAT has been verified properly. (optional)

            b2b_number_service_on_error, str: If this field is set to 'accept' and the B2B service check fails due to timeout or other issue, treat the transaction as successful. (optional)

            b2b_number_service_timeoutms, str: B2B lookup timeout in ms, please use the full endpoint for more flexibility. (optional)

            force_country_code, str: Two-letter ISO country code, e.g. FR. Use it to force country code for tax calculation. (optional)

            order_date, str: Order date in yyyy-MM-dd or yyyy-MM-dd HH:mm:ss or yyyy-MM-dd'T'HH:mm:ss'Z' format, in merchant's timezone. If provided by the API caller, no timezone conversion is performed. Default value is current date and time in merchant's timezone. When using public token, the default value is used. When time is provided, it is assumed that the date has full resolution, which affects some regions FX rate calculation - Serbia for example. (optional)

            b2b_number_service_cache_expiry_days, str: Override a number of days that the B2B validation cache applies to. Default is 30. (optional)

            amount, number: Amount. Required if total amount or both unit price and quantity are not provided. (optional)

            billing_country_code, str: Billing two letter ISO country code. (optional)

            invoice_address_postal_code, str: Invoice address/postal_code (optional)

            total_amount, number: Total amount. Required if amount or both unit price and quantity are not provided. (optional)

            tax_deducted, bool: If the transaction is in a country supported by Taxamo, but the tax is not calculated due to merchant settings or EU B2B transaction for example. (optional)

            

        Returns: calculateSimpleTaxOut
        """

        allParams = ['product_type', 'invoice_address_city', 'buyer_credit_card_prefix', 'currency_code', 'invoice_address_region', 'unit_price', 'quantity', 'buyer_tax_number', 'b2b_number_service_on_error', 'b2b_number_service_timeoutms', 'force_country_code', 'order_date', 'b2b_number_service_cache_expiry_days', 'amount', 'billing_country_code', 'invoice_address_postal_code', 'total_amount', 'tax_deducted']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method calculateSimpleTax" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/calculate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('product_type' in params):
            queryParams['product_type'] = self.apiClient.toPathValue(params['product_type'])
        if ('invoice_address_city' in params):
            queryParams['invoice_address_city'] = self.apiClient.toPathValue(params['invoice_address_city'])
        if ('buyer_credit_card_prefix' in params):
            queryParams['buyer_credit_card_prefix'] = self.apiClient.toPathValue(params['buyer_credit_card_prefix'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('invoice_address_region' in params):
            queryParams['invoice_address_region'] = self.apiClient.toPathValue(params['invoice_address_region'])
        if ('unit_price' in params):
            queryParams['unit_price'] = self.apiClient.toPathValue(params['unit_price'])
        if ('quantity' in params):
            queryParams['quantity'] = self.apiClient.toPathValue(params['quantity'])
        if ('buyer_tax_number' in params):
            queryParams['buyer_tax_number'] = self.apiClient.toPathValue(params['buyer_tax_number'])
        if ('b2b_number_service_on_error' in params):
            queryParams['b2b_number_service_on_error'] = self.apiClient.toPathValue(params['b2b_number_service_on_error'])
        if ('b2b_number_service_timeoutms' in params):
            queryParams['b2b_number_service_timeoutms'] = self.apiClient.toPathValue(params['b2b_number_service_timeoutms'])
        if ('force_country_code' in params):
            queryParams['force_country_code'] = self.apiClient.toPathValue(params['force_country_code'])
        if ('order_date' in params):
            queryParams['order_date'] = self.apiClient.toPathValue(params['order_date'])
        if ('b2b_number_service_cache_expiry_days' in params):
            queryParams['b2b_number_service_cache_expiry_days'] = self.apiClient.toPathValue(params['b2b_number_service_cache_expiry_days'])
        if ('amount' in params):
            queryParams['amount'] = self.apiClient.toPathValue(params['amount'])
        if ('billing_country_code' in params):
            queryParams['billing_country_code'] = self.apiClient.toPathValue(params['billing_country_code'])
        if ('invoice_address_postal_code' in params):
            queryParams['invoice_address_postal_code'] = self.apiClient.toPathValue(params['invoice_address_postal_code'])
        if ('total_amount' in params):
            queryParams['total_amount'] = self.apiClient.toPathValue(params['total_amount'])
        if ('tax_deducted' in params):
            queryParams['tax_deducted'] = self.apiClient.toPathValue(params['tax_deducted'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'calculateSimpleTaxOut')
        return responseObject
        

        

    def validateTaxNumber(self, tax_number, **kwargs):
        """Validate VAT number

        Args:
            country_code, str: Two-letter ISO country code. (optional)

            tax_number, str: Tax number (required)

            

        Returns: validateTaxNumberOut
        """

        allParams = ['country_code', 'tax_number']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method validateTaxNumber" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/vat_numbers/{tax_number}/validate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('country_code' in params):
            queryParams['country_code'] = self.apiClient.toPathValue(params['country_code'])
        if ('tax_number' in params):
            replacement = str(self.apiClient.toPathValue(params['tax_number']))
            resourcePath = resourcePath.replace('{' + 'tax_number' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'validateTaxNumberOut')
        return responseObject
        

        

    def calculateTaxLocation(self, **kwargs):
        """Calculate location

        Args:
            billing_country_code, str: Billing two letter ISO country code. (optional)

            buyer_credit_card_prefix, str: First 6 digits of buyer's credit card prefix. (optional)

            

        Returns: calculateTaxLocationOut
        """

        allParams = ['billing_country_code', 'buyer_credit_card_prefix']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method calculateTaxLocation" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/location/calculate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('billing_country_code' in params):
            queryParams['billing_country_code'] = self.apiClient.toPathValue(params['billing_country_code'])
        if ('buyer_credit_card_prefix' in params):
            queryParams['buyer_credit_card_prefix'] = self.apiClient.toPathValue(params['buyer_credit_card_prefix'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'calculateTaxLocationOut')
        return responseObject
        

        

    def locateMyIP(self, **kwargs):
        """Locate IP

        Args:
            

        Returns: locateMyIPOut
        """

        allParams = []

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method locateMyIP" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/geoip'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'locateMyIPOut')
        return responseObject
        

        

    def locateGivenIP(self, ip, **kwargs):
        """Locate provided IP

        Args:
            ip, str: IP address. (optional)

            

        Returns: locateGivenIPOut
        """

        allParams = ['ip']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method locateGivenIP" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/geoip/{ip}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('ip' in params):
            replacement = str(self.apiClient.toPathValue(params['ip']))
            resourcePath = resourcePath.replace('{' + 'ip' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'locateGivenIPOut')
        return responseObject
        

        

    def getTransactionsStatsByCountry(self, date_from, date_to, **kwargs):
        """Transaction stats by country

        Args:
            global_currency_code, str: Global currency code to use for conversion - in addition to country's currency if rate is available. Conversion is indicative and based on most-recent rate from ECB. (optional)

            date_from, str: Date from in yyyy-MM-dd format. (required)

            date_to, str: Date to in yyyy-MM-dd format. (required)

            

        Returns: getTransactionsStatsByCountryOut
        """

        allParams = ['global_currency_code', 'date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getTransactionsStatsByCountry" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/transactions/by_country'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('global_currency_code' in params):
            queryParams['global_currency_code'] = self.apiClient.toPathValue(params['global_currency_code'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getTransactionsStatsByCountryOut')
        return responseObject
        

        

    def getSalesStatsByCountry(self, date_from, date_to, **kwargs):
        """Sales stats by country

        Args:
            global_currency_code, str: Global currency code to use for conversion - in addition to country's currency if rate is available. Conversion is indicative and based on most-recent rate from ECB. (optional)

            date_from, str: Date from in yyyy-MM-dd format. (required)

            date_to, str: Date to in yyyy-MM-dd format. (required)

            

        Returns: getSalesStatsByCountryOut
        """

        allParams = ['global_currency_code', 'date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSalesStatsByCountry" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/sales/by_country'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('global_currency_code' in params):
            queryParams['global_currency_code'] = self.apiClient.toPathValue(params['global_currency_code'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSalesStatsByCountryOut')
        return responseObject
        

        

    def getSalesStatsForCountry(self, date_from, date_to, country_code, **kwargs):
        """Sales stats by country

        Args:
            global_currency_code, str: Global currency code to use for conversion - in addition to country's currency if rate is available. Conversion is indicative and based on most-recent rate from ECB. (optional)

            date_from, str: Date from in yyyy-MM-dd format. (required)

            date_to, str: Date to in yyyy-MM-dd format. (required)

            country_code, str: Country code (optional)

            

        Returns: getSalesStatsForCountryOut
        """

        allParams = ['global_currency_code', 'date_from', 'date_to', 'country_code']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSalesStatsForCountry" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/sales/by_country/{country_code}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('global_currency_code' in params):
            queryParams['global_currency_code'] = self.apiClient.toPathValue(params['global_currency_code'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        if ('country_code' in params):
            replacement = str(self.apiClient.toPathValue(params['country_code']))
            resourcePath = resourcePath.replace('{' + 'country_code' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSalesStatsForCountryOut')
        return responseObject
        

        

    def getTransactionsStats(self, date_from, date_to, **kwargs):
        """Transaction stats

        Args:
            date_from, str: Date from in yyyy-MM-dd format. (required)

            date_to, str: Date to in yyyy-MM-dd format. (required)

            interval, str: Interval. Accepted values are 'day', 'week' and 'month'. (optional)

            

        Returns: getTransactionsStatsOut
        """

        allParams = ['date_from', 'date_to', 'interval']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getTransactionsStats" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/transactions'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        if ('interval' in params):
            queryParams['interval'] = self.apiClient.toPathValue(params['interval'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getTransactionsStatsOut')
        return responseObject
        

        

    def getSettlementStatsByCountry(self, date_from, date_to, **kwargs):
        """Settlement by country

        Args:
            date_from, str: Date from in yyyy-MM-dd format. (required)

            date_to, str: Date to in yyyy-MM-dd format. (required)

            

        Returns: getSettlementStatsByCountryOut
        """

        allParams = ['date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlementStatsByCountry" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/settlement/by_country'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementStatsByCountryOut')
        return responseObject
        

        

    def getSettlementStatsByTaxationType(self, date_from, date_to, **kwargs):
        """Settlement by tax type

        Args:
            date_from, str: Date from in yyyy-MM-dd format. (required)

            date_to, str: Date to in yyyy-MM-dd format. (required)

            

        Returns: getSettlementStatsByTaxationTypeOut
        """

        allParams = ['date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlementStatsByTaxationType" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/settlement/by_taxation_type'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementStatsByTaxationTypeOut')
        return responseObject
        

        

    def getDailySettlementStats(self, interval, date_from, date_to, **kwargs):
        """Settlement stats over time

        Args:
            interval, str: Interval type - day, week, month. (required)

            date_from, str: Date from in yyyy-MM-dd format. (required)

            date_to, str: Date to in yyyy-MM-dd format. (required)

            

        Returns: getDailySettlementStatsOut
        """

        allParams = ['interval', 'date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getDailySettlementStats" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/settlement/daily'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('interval' in params):
            queryParams['interval'] = self.apiClient.toPathValue(params['interval'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getDailySettlementStatsOut')
        return responseObject
        

        

    def getEuViesReport(self, end_month, start_month, eu_country_code, **kwargs):
        """Calculate EU VIES report

        Args:
            period_length, str: Length of report period. 'month', 'quarter' and 'year' values are accepted. Required only if Large Filer Format is requested. (optional)

            lff_sequence_number, str: Sequence number used to generate report in Large Filer Format. If not specified then '0000000001' will be used. (optional)

            transformation, str: Which transformation should be applied. Please note that transformation will be applied only for xml and csv formats. (optional)

            currency_code, str: ISO 3-letter currency code, e.g. EUR or USD. Defaults to the one assigned to MOSS calculations for a given country code. (optional)

            end_month, str: Period end month in yyyy-MM format. (required)

            tax_id, str: MOSS-assigned tax ID - if not provided, merchant's national tax number will be used. (optional)

            start_month, str: Period start month in yyyy-MM format. (required)

            eu_country_code, str: ISO 2-letter country code which will be used for determining which country is domestic. (required)

            fx_date_type, str: Which date should be used for FX. (optional)

            format, str: Output format. 'xml', 'csv' and 'lff' (only for Ireland) values are accepted as well (optional)

            

        Returns: getEuViesReportOut
        """

        allParams = ['period_length', 'lff_sequence_number', 'transformation', 'currency_code', 'end_month', 'tax_id', 'start_month', 'eu_country_code', 'fx_date_type', 'format']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getEuViesReport" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/reports/eu/vies'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('period_length' in params):
            queryParams['period_length'] = self.apiClient.toPathValue(params['period_length'])
        if ('lff_sequence_number' in params):
            queryParams['lff_sequence_number'] = self.apiClient.toPathValue(params['lff_sequence_number'])
        if ('transformation' in params):
            queryParams['transformation'] = self.apiClient.toPathValue(params['transformation'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('end_month' in params):
            queryParams['end_month'] = self.apiClient.toPathValue(params['end_month'])
        if ('tax_id' in params):
            queryParams['tax_id'] = self.apiClient.toPathValue(params['tax_id'])
        if ('start_month' in params):
            queryParams['start_month'] = self.apiClient.toPathValue(params['start_month'])
        if ('eu_country_code' in params):
            queryParams['eu_country_code'] = self.apiClient.toPathValue(params['eu_country_code'])
        if ('fx_date_type' in params):
            queryParams['fx_date_type'] = self.apiClient.toPathValue(params['fx_date_type'])
        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getEuViesReportOut')
        return responseObject
        

        

    def getDomesticSummaryReport(self, country_code, start_month, end_month, **kwargs):
        """Calculate domestic summary

        Args:
            format, str: Output format. 'xml' and 'csv' values are accepted. Default format - json (optional)

            country_code, str: ISO 2-letter country code which will be used for determining which country is domestic. (required)

            currency_code, str: ISO 3-letter currency code, e.g. EUR or USD. Defaults to the one assigned to MOSS calculations for a given country code. (optional)

            start_month, str: Period start month in yyyy-MM format. (required)

            end_month, str: Period end month in yyyy-MM format. (required)

            fx_date_type, str: Which date should be used for FX. (optional)

            

        Returns: getDomesticSummaryReportOut
        """

        allParams = ['format', 'country_code', 'currency_code', 'start_month', 'end_month', 'fx_date_type']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getDomesticSummaryReport" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/reports/domestic/summary'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('country_code' in params):
            queryParams['country_code'] = self.apiClient.toPathValue(params['country_code'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('start_month' in params):
            queryParams['start_month'] = self.apiClient.toPathValue(params['start_month'])
        if ('end_month' in params):
            queryParams['end_month'] = self.apiClient.toPathValue(params['end_month'])
        if ('fx_date_type' in params):
            queryParams['fx_date_type'] = self.apiClient.toPathValue(params['fx_date_type'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getDomesticSummaryReportOut')
        return responseObject
        

        

    def getDetailedRefunds(self, **kwargs):
        """Detailed refunds

        Args:
            format, str: Output format. 'json' or 'csv'. Default value is 'json' (optional)

            country_codes, str: Comma separated list of 2-letter country codes (optional)

            date_from, str: Take only refunds issued at or after the date. Format: yyyy-MM-dd (optional)

            date_to, str: Take only refunds issued at or before the date. Format: yyyy-MM-dd (optional)

            custom_fields, str: Comma separated list of custom fields (optional)

            limit, number: Limit (no more than 1000, defaults to 100). (optional)

            offset, number: Offset. Defaults to 0 (optional)

            

        Returns: getDetailedRefundsOut
        """

        allParams = ['format', 'country_codes', 'date_from', 'date_to', 'custom_fields', 'limit', 'offset']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getDetailedRefunds" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/settlement/detailed_refunds'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('country_codes' in params):
            queryParams['country_codes'] = self.apiClient.toPathValue(params['country_codes'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        if ('custom_fields' in params):
            queryParams['custom_fields'] = self.apiClient.toPathValue(params['custom_fields'])
        if ('limit' in params):
            queryParams['limit'] = self.apiClient.toPathValue(params['limit'])
        if ('offset' in params):
            queryParams['offset'] = self.apiClient.toPathValue(params['offset'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getDetailedRefundsOut')
        return responseObject
        

        

    def getRefunds(self, date_from, **kwargs):
        """Fetch refunds

        Args:
            format, str: Output format. 'csv' value is accepted as well (optional)

            moss_country_code, str: MOSS country code, used to determine currency. If ommited, merchant default setting is used. (optional)

            tax_region, str: Tax region key, defaults to EU for backwards compatibility. (optional)

            date_from, str: Take only refunds issued at or after the date. Format: yyyy-MM-dd (required)

            

        Returns: getRefundsOut
        """

        allParams = ['format', 'moss_country_code', 'tax_region', 'date_from']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getRefunds" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/settlement/refunds'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('moss_country_code' in params):
            queryParams['moss_country_code'] = self.apiClient.toPathValue(params['moss_country_code'])
        if ('tax_region' in params):
            queryParams['tax_region'] = self.apiClient.toPathValue(params['tax_region'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getRefundsOut')
        return responseObject
        

        

    def getSettlement(self, quarter, **kwargs):
        """Fetch settlement

        Args:
            moss_tax_id, str: MOSS-assigned tax ID - if not provided, merchant's national tax number will be used. Deprecated, please use tax-id. (optional)

            currency_code, str: ISO 3-letter currency code, e.g. EUR or USD. If provided, all amounts will be coerced for this currency. Defaults to region's currency code. (optional)

            end_month, str: Period end month in yyyy-MM format. Either quarter or start-month and end-month have to be provided. (optional)

            tax_id, str: MOSS-assigned tax ID - if not provided, merchant's national tax number will be used. Deprecated, please use tax-id. (optional)

            refund_date_kind_override, str: Set to 'order_date' to show only refunds for the transactions in the selected reporting period. Set to 'refund_timestamp' to show refunds that were created in the selected reporting period. Do not set to use the default region's setting. (optional)

            start_month, str: Period start month in yyyy-MM format. Either quarter or start-month and end-month have to be provided. (optional)

            moss_country_code, str: MOSS country code, used to determine currency/region. If ommited, merchant default setting is used. Deprecated: please use tax-country-code. (optional)

            period, str: Name of period used in csv export with report parameters included (optional)

            format, str: Output format. 'csv' value is accepted as well (optional)

            tax_country_code, str: Tax entity country code, used to determine currency/region.  (optional)

            quarter, str: Quarter in yyyy-MM format. If start-date and end-date are provided, quarter is ignored and should be set to 'range'. (required)

            

        Returns: getSettlementOut
        """

        allParams = ['moss_tax_id', 'currency_code', 'end_month', 'tax_id', 'refund_date_kind_override', 'start_month', 'moss_country_code', 'period', 'format', 'tax_country_code', 'quarter']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlement" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/settlement/{quarter}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('moss_tax_id' in params):
            queryParams['moss_tax_id'] = self.apiClient.toPathValue(params['moss_tax_id'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('end_month' in params):
            queryParams['end_month'] = self.apiClient.toPathValue(params['end_month'])
        if ('tax_id' in params):
            queryParams['tax_id'] = self.apiClient.toPathValue(params['tax_id'])
        if ('refund_date_kind_override' in params):
            queryParams['refund_date_kind_override'] = self.apiClient.toPathValue(params['refund_date_kind_override'])
        if ('start_month' in params):
            queryParams['start_month'] = self.apiClient.toPathValue(params['start_month'])
        if ('moss_country_code' in params):
            queryParams['moss_country_code'] = self.apiClient.toPathValue(params['moss_country_code'])
        if ('period' in params):
            queryParams['period'] = self.apiClient.toPathValue(params['period'])
        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('tax_country_code' in params):
            queryParams['tax_country_code'] = self.apiClient.toPathValue(params['tax_country_code'])
        if ('quarter' in params):
            replacement = str(self.apiClient.toPathValue(params['quarter']))
            resourcePath = resourcePath.replace('{' + 'quarter' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementOut')
        return responseObject
        

        

    def getSettlementSummary(self, quarter, **kwargs):
        """Fetch summary

        Args:
            moss_country_code, str: MOSS country code, used to determine currency. If ommited, merchant default setting is used. (optional)

            tax_region, str: Tax region key (optional)

            start_month, str: Period start month in yyyy-MM format. Either quarter or start-month and end-month have to be provided. (optional)

            end_month, str: Period end month in yyyy-MM format. Either quarter or start-month and end-month have to be provided. (optional)

            quarter, str: Quarter in yyyy-MM format. If start-date and end-date are provided, quarter is ignored and should be set to 'range'. (required)

            

        Returns: getSettlementSummaryOut
        """

        allParams = ['moss_country_code', 'tax_region', 'start_month', 'end_month', 'quarter']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlementSummary" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/settlement/summary/{quarter}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('moss_country_code' in params):
            queryParams['moss_country_code'] = self.apiClient.toPathValue(params['moss_country_code'])
        if ('tax_region' in params):
            queryParams['tax_region'] = self.apiClient.toPathValue(params['tax_region'])
        if ('start_month' in params):
            queryParams['start_month'] = self.apiClient.toPathValue(params['start_month'])
        if ('end_month' in params):
            queryParams['end_month'] = self.apiClient.toPathValue(params['end_month'])
        if ('quarter' in params):
            replacement = str(self.apiClient.toPathValue(params['quarter']))
            resourcePath = resourcePath.replace('{' + 'quarter' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementSummaryOut')
        return responseObject
        

        

    def createSMSToken(self, body, **kwargs):
        """Create SMS token

        Args:
            body, createSMSTokenIn: Input (required)

            

        Returns: createSMSTokenOut
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createSMSToken" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/verification/sms'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createSMSTokenOut')
        return responseObject
        

        

    def verifySMSToken(self, token, **kwargs):
        """Verify SMS token

        Args:
            token, str: Provided token. (required)

            

        Returns: verifySMSTokenOut
        """

        allParams = ['token']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method verifySMSToken" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/verification/sms/{token}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('token' in params):
            replacement = str(self.apiClient.toPathValue(params['token']))
            resourcePath = resourcePath.replace('{' + 'token' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'verifySMSTokenOut')
        return responseObject
        

        

    def getCurrenciesDict(self, **kwargs):
        """Currencies

        Args:
            

        Returns: getCurrenciesDictOut
        """

        allParams = []

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getCurrenciesDict" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/dictionaries/currencies'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getCurrenciesDictOut')
        return responseObject
        

        

    def getProductTypesDict(self, **kwargs):
        """Product types

        Args:
            

        Returns: getProductTypesDictOut
        """

        allParams = []

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getProductTypesDict" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/dictionaries/product_types'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getProductTypesDictOut')
        return responseObject
        

        

    def getCountriesDict(self, **kwargs):
        """Countries

        Args:
            tax_supported, bool: Should only countries with tax supported be listed? (optional)

            

        Returns: getCountriesDictOut
        """

        allParams = ['tax_supported']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getCountriesDict" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/dictionaries/countries'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('tax_supported' in params):
            queryParams['tax_supported'] = self.apiClient.toPathValue(params['tax_supported'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getCountriesDictOut')
        return responseObject
        

        

    




