#!/usr/bin/env python
"""
Copyright 2014-2015 Taxamo, Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at [apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0)

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
"""
import sys
import os

from models import *


class ApiApi(object):

    def __init__(self, apiClient):
      self.apiClient = apiClient

    

    def createRefund(self, key, body, **kwargs):
        """Create a refund

        Args:
            key, str: Transaction key. (required)

            body, createRefundIn: Input (required)

            

        Returns: createRefundOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createRefund" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/refunds'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createRefundOut')
        return responseObject
        

        

    def listRefunds(self, key, **kwargs):
        """Get transaction refunds

        Args:
            key, str: Transaction key. (required)

            

        Returns: listRefundsOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listRefunds" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/refunds'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'listRefundsOut')
        return responseObject
        

        

    def createPayment(self, key, body, **kwargs):
        """Register a payment

        Args:
            key, str: Transaction key. (required)

            body, createPaymentIn: Input (required)

            

        Returns: createPaymentOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createPayment" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/payments'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createPaymentOut')
        return responseObject
        

        

    def listPayments(self, key, **kwargs):
        """List payments

        Args:
            limit, str: Max record count (no more than 100, defaults to 10). (optional)

            offset, str: How many records need to be skipped, defaults to 0. (optional)

            key, str: Transaction key. (required)

            

        Returns: listPaymentsOut
        """

        allParams = ['limit', 'offset', 'key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listPayments" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/payments'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('limit' in params):
            queryParams['limit'] = self.apiClient.toPathValue(params['limit'])
        if ('offset' in params):
            queryParams['offset'] = self.apiClient.toPathValue(params['offset'])
        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'listPaymentsOut')
        return responseObject
        

        

    def capturePayment(self, key, **kwargs):
        """Capture payment

        Args:
            key, str: Transaction key. (required)

            

        Returns: capturePaymentOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method capturePayment" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/payments/capture'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'capturePaymentOut')
        return responseObject
        

        

    def emailInvoice(self, key, body, **kwargs):
        """Email invoice

        Args:
            key, str: Transaction key. (optional)

            body, emailInvoiceIn: Input (required)

            

        Returns: emailInvoiceOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method emailInvoice" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/invoice/send_email'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'emailInvoiceOut')
        return responseObject
        

        

    def emailRefund(self, key, refund_note_number, body, **kwargs):
        """Email invoice

        Args:
            key, str: Transaction key. (required)

            refund_note_number, str: Refund note id. (required)

            body, emailRefundIn: Input (required)

            

        Returns: emailRefundOut
        """

        allParams = ['key', 'refund_note_number', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method emailRefund" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/invoice/refunds/{refund_note_number}/send_email'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        if ('refund_note_number' in params):
            replacement = str(self.apiClient.toPathValue(params['refund_note_number']))
            resourcePath = resourcePath.replace('{' + 'refund_note_number' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'emailRefundOut')
        return responseObject
        

        

    def createTransaction(self, body, **kwargs):
        """Store transaction

        Args:
            body, createTransactionIn: Input (required)

            

        Returns: createTransactionOut
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createTransactionOut')
        return responseObject
        

        

    def getTransaction(self, key, **kwargs):
        """Retrieve transaction data.

        Args:
            key, str: Transaction key (required)

            

        Returns: getTransactionOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getTransactionOut')
        return responseObject
        

        

    def updateTransaction(self, key, body, **kwargs):
        """Update transaction

        Args:
            key, str: Transaction key. (optional)

            body, updateTransactionIn: Input (required)

            

        Returns: updateTransactionOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method updateTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'updateTransactionOut')
        return responseObject
        

        

    def confirmTransaction(self, key, body, **kwargs):
        """Confirm transaction

        Args:
            key, str: Transaction key. (optional)

            body, confirmTransactionIn: Input (required)

            

        Returns: confirmTransactionOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method confirmTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/confirm'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'confirmTransactionOut')
        return responseObject
        

        

    def cancelTransaction(self, key, **kwargs):
        """Delete transaction

        Args:
            key, str: Transaction key (optional)

            

        Returns: cancelTransactionOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method cancelTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'cancelTransactionOut')
        return responseObject
        

        

    def unconfirmTransaction(self, key, body, **kwargs):
        """Un-confirm the transaction. Un-confirmed transaction can be edited or canceled like a newly created one.

        Args:
            key, str: Transaction key. (optional)

            body, unconfirmTransactionIn: Input (required)

            

        Returns: unconfirmTransactionOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method unconfirmTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/unconfirm'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'unconfirmTransactionOut')
        return responseObject
        

        

    def listTransactions(self, **kwargs):
        """Browse transactions

        Args:
            filter_text, str: Filtering expression (optional)

            offset, integer: Offset (optional)

            key_or_custom_id, str: Taxamo provided transaction key or custom id (optional)

            currency_code, str: Three letter ISO currency code. (optional)

            order_date_to, str: Order date to in yyyy-MM-dd format. (optional)

            sort_reverse, bool: If true, results are sorted in descending order. (optional)

            limit, integer: Limit (no more than 1000, defaults to 100). (optional)

            invoice_number, str: Transaction invoice number. (optional)

            statuses, str: Comma separated list of of transaction statuses. 'N' - unconfirmed transaction, 'C' - confirmed transaction. (optional)

            original_transaction_key, str: Taxamo provided original transaction key (optional)

            order_date_from, str: Order date from in yyyy-MM-dd format. (optional)

            total_amount_greater_than, str: Return only transactions with total amount greater than given number. Transactions with total amount equal to a given number (e.g. 0) are not returned. (optional)

            format, str: Output format - supports 'csv' value for this operation. (optional)

            total_amount_less_than, str: Return only transactions with total amount less than a given number. Transactions with total amount equal to a given number (e.g. 1) are not returned. (optional)

            tax_country_code, str: Two letter ISO tax country code. (optional)

            

        Returns: listTransactionsOut
        """

        allParams = ['filter_text', 'offset', 'key_or_custom_id', 'currency_code', 'order_date_to', 'sort_reverse', 'limit', 'invoice_number', 'statuses', 'original_transaction_key', 'order_date_from', 'total_amount_greater_than', 'format', 'total_amount_less_than', 'tax_country_code']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listTransactions" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('filter_text' in params):
            queryParams['filter_text'] = self.apiClient.toPathValue(params['filter_text'])
        if ('offset' in params):
            queryParams['offset'] = self.apiClient.toPathValue(params['offset'])
        if ('key_or_custom_id' in params):
            queryParams['key_or_custom_id'] = self.apiClient.toPathValue(params['key_or_custom_id'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('order_date_to' in params):
            queryParams['order_date_to'] = self.apiClient.toPathValue(params['order_date_to'])
        if ('sort_reverse' in params):
            queryParams['sort_reverse'] = self.apiClient.toPathValue(params['sort_reverse'])
        if ('limit' in params):
            queryParams['limit'] = self.apiClient.toPathValue(params['limit'])
        if ('invoice_number' in params):
            queryParams['invoice_number'] = self.apiClient.toPathValue(params['invoice_number'])
        if ('statuses' in params):
            queryParams['statuses'] = self.apiClient.toPathValue(params['statuses'])
        if ('original_transaction_key' in params):
            queryParams['original_transaction_key'] = self.apiClient.toPathValue(params['original_transaction_key'])
        if ('order_date_from' in params):
            queryParams['order_date_from'] = self.apiClient.toPathValue(params['order_date_from'])
        if ('total_amount_greater_than' in params):
            queryParams['total_amount_greater_than'] = self.apiClient.toPathValue(params['total_amount_greater_than'])
        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('total_amount_less_than' in params):
            queryParams['total_amount_less_than'] = self.apiClient.toPathValue(params['total_amount_less_than'])
        if ('tax_country_code' in params):
            queryParams['tax_country_code'] = self.apiClient.toPathValue(params['tax_country_code'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'listTransactionsOut')
        return responseObject
        

        

    def calculateTax(self, body, **kwargs):
        """Calculate tax

        Args:
            body, calculateTaxIn: Input (required)

            

        Returns: calculateTaxOut
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method calculateTax" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/calculate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'calculateTaxOut')
        return responseObject
        

        

    def calculateSimpleTax(self, currency_code, **kwargs):
        """Simple tax

        Args:
            product_type, str: Product type, according to dictionary /dictionaries/product_types.  (optional)

            invoice_address_city, str: Invoice address/postal_code (optional)

            buyer_credit_card_prefix, str: Buyer's credit card prefix. (optional)

            currency_code, str: Currency code for transaction - e.g. EUR. (required)

            invoice_address_region, str: Invoice address/region (optional)

            unit_price, number: Unit price. (optional)

            quantity, number: Quantity Defaults to 1. (optional)

            buyer_tax_number, str:  Buyer's tax number - EU VAT number for example. If using EU VAT number, it is possible to provide country code in it (e.g. IE1234567X) or simply use billing_country_code field for that. In the first case, if billing_country_code value was provided, it will be overwritten with country code value extracted from VAT number - but only if the VAT has been verified properly. (optional)

            force_country_code, str: Two-letter ISO country code, e.g. FR. Use it to force country code for tax calculation. (optional)

            order_date, str: Order date in yyyy-MM-dd format, in merchant's timezone. If provided by the API caller, no timezone conversion is performed. Default value is current date and time. When using public token, the default value is used. (optional)

            amount, number: Amount. Required if total amount is not provided. (optional)

            billing_country_code, str: Billing two letter ISO country code. (optional)

            invoice_address_postal_code, str: Invoice address/postal_code (optional)

            total_amount, number: Total amount. Required if amount is not provided. (optional)

            tax_deducted, bool: If the transaction is in a country supported by Taxamo, but the tax is not calculated due to merchant settings or EU B2B transaction for example. (optional)

            

        Returns: calculateSimpleTaxOut
        """

        allParams = ['product_type', 'invoice_address_city', 'buyer_credit_card_prefix', 'currency_code', 'invoice_address_region', 'unit_price', 'quantity', 'buyer_tax_number', 'force_country_code', 'order_date', 'amount', 'billing_country_code', 'invoice_address_postal_code', 'total_amount', 'tax_deducted']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method calculateSimpleTax" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/calculate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('product_type' in params):
            queryParams['product_type'] = self.apiClient.toPathValue(params['product_type'])
        if ('invoice_address_city' in params):
            queryParams['invoice_address_city'] = self.apiClient.toPathValue(params['invoice_address_city'])
        if ('buyer_credit_card_prefix' in params):
            queryParams['buyer_credit_card_prefix'] = self.apiClient.toPathValue(params['buyer_credit_card_prefix'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('invoice_address_region' in params):
            queryParams['invoice_address_region'] = self.apiClient.toPathValue(params['invoice_address_region'])
        if ('unit_price' in params):
            queryParams['unit_price'] = self.apiClient.toPathValue(params['unit_price'])
        if ('quantity' in params):
            queryParams['quantity'] = self.apiClient.toPathValue(params['quantity'])
        if ('buyer_tax_number' in params):
            queryParams['buyer_tax_number'] = self.apiClient.toPathValue(params['buyer_tax_number'])
        if ('force_country_code' in params):
            queryParams['force_country_code'] = self.apiClient.toPathValue(params['force_country_code'])
        if ('order_date' in params):
            queryParams['order_date'] = self.apiClient.toPathValue(params['order_date'])
        if ('amount' in params):
            queryParams['amount'] = self.apiClient.toPathValue(params['amount'])
        if ('billing_country_code' in params):
            queryParams['billing_country_code'] = self.apiClient.toPathValue(params['billing_country_code'])
        if ('invoice_address_postal_code' in params):
            queryParams['invoice_address_postal_code'] = self.apiClient.toPathValue(params['invoice_address_postal_code'])
        if ('total_amount' in params):
            queryParams['total_amount'] = self.apiClient.toPathValue(params['total_amount'])
        if ('tax_deducted' in params):
            queryParams['tax_deducted'] = self.apiClient.toPathValue(params['tax_deducted'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'calculateSimpleTaxOut')
        return responseObject
        

        

    def validateTaxNumber(self, tax_number, **kwargs):
        """Validate VAT number

        Args:
            country_code, str: Two-letter ISO country code. (optional)

            tax_number, str: Tax number (required)

            

        Returns: validateTaxNumberOut
        """

        allParams = ['country_code', 'tax_number']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method validateTaxNumber" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/vat_numbers/{tax_number}/validate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('country_code' in params):
            queryParams['country_code'] = self.apiClient.toPathValue(params['country_code'])
        if ('tax_number' in params):
            replacement = str(self.apiClient.toPathValue(params['tax_number']))
            resourcePath = resourcePath.replace('{' + 'tax_number' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'validateTaxNumberOut')
        return responseObject
        

        

    def calculateTaxLocation(self, **kwargs):
        """Calculate location

        Args:
            billing_country_code, str: Billing two letter ISO country code. (optional)

            buyer_credit_card_prefix, str: Buyer's credit card prefix. (optional)

            

        Returns: calculateTaxLocationOut
        """

        allParams = ['billing_country_code', 'buyer_credit_card_prefix']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method calculateTaxLocation" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/location/calculate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('billing_country_code' in params):
            queryParams['billing_country_code'] = self.apiClient.toPathValue(params['billing_country_code'])
        if ('buyer_credit_card_prefix' in params):
            queryParams['buyer_credit_card_prefix'] = self.apiClient.toPathValue(params['buyer_credit_card_prefix'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'calculateTaxLocationOut')
        return responseObject
        

        

    def locateMyIP(self, **kwargs):
        """Locate IP

        Args:
            

        Returns: locateMyIPOut
        """

        allParams = []

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method locateMyIP" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/geoip'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'locateMyIPOut')
        return responseObject
        

        

    def locateGivenIP(self, ip, **kwargs):
        """Locate provided IP

        Args:
            ip, str: IP address. (optional)

            

        Returns: locateGivenIPOut
        """

        allParams = ['ip']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method locateGivenIP" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/geoip/{ip}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('ip' in params):
            replacement = str(self.apiClient.toPathValue(params['ip']))
            resourcePath = resourcePath.replace('{' + 'ip' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'locateGivenIPOut')
        return responseObject
        

        

    def getTransactionsStatsByCountry(self, date_from, date_to, **kwargs):
        """Settlement by country

        Args:
            global_currency_code, str: Global currency code to use for conversion - in addition to country's currency if rate is available. Conversion is indicative and based on most-recent rate from ECB. (optional)

            date_from, str: Date from in yyyy-MM format. (required)

            date_to, str: Date to in yyyy-MM format. (required)

            

        Returns: getTransactionsStatsByCountryOut
        """

        allParams = ['global_currency_code', 'date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getTransactionsStatsByCountry" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/transactions/by_country'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('global_currency_code' in params):
            queryParams['global_currency_code'] = self.apiClient.toPathValue(params['global_currency_code'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getTransactionsStatsByCountryOut')
        return responseObject
        

        

    def getTransactionsStats(self, date_from, date_to, **kwargs):
        """Transaction stats

        Args:
            date_from, str: Date from in yyyy-MM format. (required)

            date_to, str: Date to in yyyy-MM format. (required)

            interval, str: Interval. Accepted values are 'day', 'week' and 'month'. (optional)

            

        Returns: getTransactionsStatsOut
        """

        allParams = ['date_from', 'date_to', 'interval']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getTransactionsStats" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/transactions'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        if ('interval' in params):
            queryParams['interval'] = self.apiClient.toPathValue(params['interval'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getTransactionsStatsOut')
        return responseObject
        

        

    def getSettlementStatsByCountry(self, date_from, date_to, **kwargs):
        """Settlement by country

        Args:
            date_from, str: Date from in yyyy-MM format. (required)

            date_to, str: Date to in yyyy-MM format. (required)

            

        Returns: getSettlementStatsByCountryOut
        """

        allParams = ['date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlementStatsByCountry" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/settlement/by_country'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementStatsByCountryOut')
        return responseObject
        

        

    def getSettlementStatsByTaxationType(self, date_from, date_to, **kwargs):
        """Settlement by tax type

        Args:
            date_from, str: Date from in yyyy-MM format. (required)

            date_to, str: Date to in yyyy-MM format. (required)

            

        Returns: getSettlementStatsByTaxationTypeOut
        """

        allParams = ['date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlementStatsByTaxationType" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/settlement/by_taxation_type'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementStatsByTaxationTypeOut')
        return responseObject
        

        

    def getDailySettlementStats(self, interval, date_from, date_to, **kwargs):
        """Settlement stats over time

        Args:
            interval, str: Interval type - day, week, month. (required)

            date_from, str: Date from in yyyy-MM format. (required)

            date_to, str: Date to in yyyy-MM format. (required)

            

        Returns: getDailySettlementStatsOut
        """

        allParams = ['interval', 'date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getDailySettlementStats" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/settlement/daily'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('interval' in params):
            queryParams['interval'] = self.apiClient.toPathValue(params['interval'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getDailySettlementStatsOut')
        return responseObject
        

        

    def getEuViesReport(self, eu_country_code, start_month, end_month, **kwargs):
        """Calculate EU VIES report.

        Args:
            format, str: Output format. 'xml' and 'csv' values are accepted as well (optional)

            transformation, str: Which transformation should be applied. Please note that transformation will be applied only for xml and csv formats. (optional)

            eu_country_code, str: ISO 2-letter country code which will be used for determining which country is domestic. (required)

            currency_code, str: ISO 3-letter currency code, e.g. EUR or USD. Defaults to the one assigned to MOSS calculations for a given country code. (optional)

            tax_id, str: MOSS-assigned tax ID - if not provided, merchant's national tax number will be used. (optional)

            start_month, str: Period start month in yyyy-MM format. (required)

            end_month, str: Period end month in yyyy-MM-dd format. (required)

            fx_date_type, str: Which date should be used for FX. (optional)

            

        Returns: getEuViesReportOut
        """

        allParams = ['format', 'transformation', 'eu_country_code', 'currency_code', 'tax_id', 'start_month', 'end_month', 'fx_date_type']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getEuViesReport" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/reports/eu/vies'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('transformation' in params):
            queryParams['transformation'] = self.apiClient.toPathValue(params['transformation'])
        if ('eu_country_code' in params):
            queryParams['eu_country_code'] = self.apiClient.toPathValue(params['eu_country_code'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('tax_id' in params):
            queryParams['tax_id'] = self.apiClient.toPathValue(params['tax_id'])
        if ('start_month' in params):
            queryParams['start_month'] = self.apiClient.toPathValue(params['start_month'])
        if ('end_month' in params):
            queryParams['end_month'] = self.apiClient.toPathValue(params['end_month'])
        if ('fx_date_type' in params):
            queryParams['fx_date_type'] = self.apiClient.toPathValue(params['fx_date_type'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getEuViesReportOut')
        return responseObject
        

        

    def getDomesticSummaryReport(self, country_code, start_month, end_month, **kwargs):
        """Calculate domestic summary.

        Args:
            format, str: Output format. 'xml' and 'csv' values are accepted. Default format - json (optional)

            country_code, str: ISO 2-letter country code which will be used for determining which country is domestic. (required)

            currency_code, str: ISO 3-letter currency code, e.g. EUR or USD. Defaults to the one assigned to MOSS calculations for a given country code. (optional)

            start_month, str: Period start month in yyyy-MM format. (required)

            end_month, str: Period end month in yyyy-MM-dd format. (required)

            fx_date_type, str: Which date should be used for FX. (optional)

            

        Returns: getDomesticSummaryReportOut
        """

        allParams = ['format', 'country_code', 'currency_code', 'start_month', 'end_month', 'fx_date_type']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getDomesticSummaryReport" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/reports/domestic/summary'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('country_code' in params):
            queryParams['country_code'] = self.apiClient.toPathValue(params['country_code'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('start_month' in params):
            queryParams['start_month'] = self.apiClient.toPathValue(params['start_month'])
        if ('end_month' in params):
            queryParams['end_month'] = self.apiClient.toPathValue(params['end_month'])
        if ('fx_date_type' in params):
            queryParams['fx_date_type'] = self.apiClient.toPathValue(params['fx_date_type'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getDomesticSummaryReportOut')
        return responseObject
        

        

    def getRefunds(self, date_from, **kwargs):
        """Fetch refunds

        Args:
            format, str: Output format. 'csv' value is accepted as well (optional)

            moss_country_code, str: MOSS country code, used to determine currency. If ommited, merchant default setting is used. (optional)

            tax_region, str: Tax region key, defaults to EU for backwards compatibility. (optional)

            date_from, str: Take only refunds issued at or after the date. Format: yyyy-MM-dd (required)

            

        Returns: getRefundsOut
        """

        allParams = ['format', 'moss_country_code', 'tax_region', 'date_from']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getRefunds" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/settlement/refunds'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('moss_country_code' in params):
            queryParams['moss_country_code'] = self.apiClient.toPathValue(params['moss_country_code'])
        if ('tax_region' in params):
            queryParams['tax_region'] = self.apiClient.toPathValue(params['tax_region'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getRefundsOut')
        return responseObject
        

        

    def getSettlement(self, quarter, **kwargs):
        """Fetch settlement

        Args:
            format, str: Output format. 'csv' value is accepted as well (optional)

            moss_country_code, str: MOSS country code, used to determine currency/region. If ommited, merchant default setting is used. Deprecated: please use tax-country-code. (optional)

            tax_country_code, str: Tax entity country code, used to determine currency/region.  (optional)

            currency_code, str: ISO 3-letter currency code, e.g. EUR or USD. If provided, all amounts will be coerced for this currency. Defaults to region's currency code. (optional)

            moss_tax_id, str: MOSS-assigned tax ID - if not provided, merchant's national tax number will be used. Deprecated, please use tax-id. (optional)

            tax_id, str: MOSS-assigned tax ID - if not provided, merchant's national tax number will be used. Deprecated, please use tax-id. (optional)

            start_month, str: Period start month in yyyy-MM format. Either quarter or start-month and end-month have to be provided. (optional)

            end_month, str: Period end month in yyyy-MM-dd format. Either quarter or start-month and end-month have to be provided. (optional)

            quarter, str: Quarter in yyyy-MM format. If start-date and end-date are provided, quarter is ignored and should be set to 'range'. (required)

            

        Returns: getSettlementOut
        """

        allParams = ['format', 'moss_country_code', 'tax_country_code', 'currency_code', 'moss_tax_id', 'tax_id', 'start_month', 'end_month', 'quarter']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlement" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/settlement/{quarter}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('moss_country_code' in params):
            queryParams['moss_country_code'] = self.apiClient.toPathValue(params['moss_country_code'])
        if ('tax_country_code' in params):
            queryParams['tax_country_code'] = self.apiClient.toPathValue(params['tax_country_code'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('moss_tax_id' in params):
            queryParams['moss_tax_id'] = self.apiClient.toPathValue(params['moss_tax_id'])
        if ('tax_id' in params):
            queryParams['tax_id'] = self.apiClient.toPathValue(params['tax_id'])
        if ('start_month' in params):
            queryParams['start_month'] = self.apiClient.toPathValue(params['start_month'])
        if ('end_month' in params):
            queryParams['end_month'] = self.apiClient.toPathValue(params['end_month'])
        if ('quarter' in params):
            replacement = str(self.apiClient.toPathValue(params['quarter']))
            resourcePath = resourcePath.replace('{' + 'quarter' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementOut')
        return responseObject
        

        

    def getSettlementSummary(self, quarter, **kwargs):
        """Fetch summary

        Args:
            moss_country_code, str: MOSS country code, used to determine currency. If ommited, merchant default setting is used. (optional)

            tax_region, str: Tax region key (optional)

            start_month, str: Period start month in yyyy-MM format. Either quarter or start-month and end-month have to be provided. (optional)

            end_month, str: Period end month in yyyy-MM-dd format. Either quarter or start-month and end-month have to be provided. (optional)

            quarter, str: Quarter in yyyy-MM format. If start-date and end-date are provided, quarter is ignored and should be set to 'range'. (required)

            

        Returns: getSettlementSummaryOut
        """

        allParams = ['moss_country_code', 'tax_region', 'start_month', 'end_month', 'quarter']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlementSummary" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/settlement/summary/{quarter}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('moss_country_code' in params):
            queryParams['moss_country_code'] = self.apiClient.toPathValue(params['moss_country_code'])
        if ('tax_region' in params):
            queryParams['tax_region'] = self.apiClient.toPathValue(params['tax_region'])
        if ('start_month' in params):
            queryParams['start_month'] = self.apiClient.toPathValue(params['start_month'])
        if ('end_month' in params):
            queryParams['end_month'] = self.apiClient.toPathValue(params['end_month'])
        if ('quarter' in params):
            replacement = str(self.apiClient.toPathValue(params['quarter']))
            resourcePath = resourcePath.replace('{' + 'quarter' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementSummaryOut')
        return responseObject
        

        

    def createSMSToken(self, body, **kwargs):
        """Create SMS token

        Args:
            body, createSMSTokenIn: Input (required)

            

        Returns: createSMSTokenOut
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createSMSToken" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/verification/sms'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createSMSTokenOut')
        return responseObject
        

        

    def verifySMSToken(self, token, **kwargs):
        """Verify SMS token

        Args:
            token, str: Provided token. (required)

            

        Returns: verifySMSTokenOut
        """

        allParams = ['token']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method verifySMSToken" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/verification/sms/{token}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('token' in params):
            replacement = str(self.apiClient.toPathValue(params['token']))
            resourcePath = resourcePath.replace('{' + 'token' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'verifySMSTokenOut')
        return responseObject
        

        

    def getCurrenciesDict(self, **kwargs):
        """Currencies

        Args:
            

        Returns: getCurrenciesDictOut
        """

        allParams = []

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getCurrenciesDict" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/dictionaries/currencies'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getCurrenciesDictOut')
        return responseObject
        

        

    def getProductTypesDict(self, **kwargs):
        """Product types

        Args:
            

        Returns: getProductTypesDictOut
        """

        allParams = []

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getProductTypesDict" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/dictionaries/product_types'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getProductTypesDictOut')
        return responseObject
        

        

    def getCountriesDict(self, **kwargs):
        """Countries

        Args:
            tax_supported, bool: Should only countries with tax supported be listed? (optional)

            

        Returns: getCountriesDictOut
        """

        allParams = ['tax_supported']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getCountriesDict" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/dictionaries/countries'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('tax_supported' in params):
            queryParams['tax_supported'] = self.apiClient.toPathValue(params['tax_supported'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getCountriesDictOut')
        return responseObject
        

        

    




